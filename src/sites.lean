import category_theory.opposites
import category_theory.limits.shapes.products
import category_theory.limits.shapes.pullbacks
import sieve

namespace category_theory
namespace category_theory.limits

section topologies
universes v u

variables (C : Type u) [category.{v} C]

-- SGA 4 II Def 1.1.
structure grothendieck_topology :=
(coverings : Œ† (X : C), set (sieve.{v} X))
(base_change : ‚àÄ (X Y : C) (S : sieve.{v} X) (f : Y ‚ü∂ X), 
    S ‚àà coverings X ‚Üí (pullback_sieve f S) ‚àà coverings Y)
(local_character : ‚àÄ (X : C) (S T : sieve.{v} X) (_ : S ‚àà coverings X), 
    (‚àÄ (Y : C) (f : Y ‚ü∂ X) (_ : f ‚àà S.map Y), 
         (pullback_sieve f T) ‚àà coverings Y) ‚Üí T ‚àà coverings X)
(id : ‚àÄ (X : C), id_sieve X ‚àà coverings X)

--TODO coverings is 'cofiltrant' [SGA 4 II 1.1.1.]

-- how to generate this? @[ext] didn't work for because of the explicit universe parameters
lemma grothendieck_topology_ext {J K : grothendieck_topology C}:
    J.coverings = K.coverings ‚Üí J = K := by {cases K, intro H, cases J, tidy}

-- SGA 4 II 1.1.2. topologies plus ou moins fine
instance grothendieck_topology_partial_order:
    partial_order (grothendieck_topology C) :=
    {   le := (Œª J, Œª K, J.coverings ‚â§ K.coverings),
        le_refl := by {intros J X, exact le_refl (J.coverings X), },
        le_trans := by {intros J K L hJK hKL X, exact le_trans (hJK X) (hKL X),},
        le_antisymm := by {
            intros J K hJK hKJ, 
            apply grothendieck_topology_ext, ext X S,
            split,
            intro hS,
            exact hJK X hS,
            intro hS,
            exact hKJ X hS, }
    }

-- SGA 4 II 1.1.3. intersection topology
instance grothendieck_topology_has_Inf:
    lattice.has_Inf (grothendieck_topology C) :=
    { Inf := Œª T : set (grothendieck_topology C), ‚ü® Œª U : C, 
            ‚ãÇ (J : grothendieck_topology C) (H : J ‚àà T), J.coverings U,
        by { tidy, apply H_w.base_change, exact a H_w H_w_1, },
        by { 
            tidy, 
            apply H_w.local_character X S T_1, 
            exact _x H_w H_w_1,
            intros Y f hf,
            exact a Y f hf H_w H_w_1, },
        by {tidy, exact H_w.id X, } ‚ü© }

-- SGA 4 II 1.1.4. discrete (top) and chaotic (bot) topologies
instance grothendieck_topology_order_top:
    lattice.order_top (grothendieck_topology C) :=
    { top := ‚ü®Œª U, {a | true}, by tidy, by tidy, by tidy‚ü©,
      le_top := by tidy,
      ..grothendieck_topology_partial_order C}

instance grothendieck_topology_order_bot:
    lattice.order_bot (grothendieck_topology C) :=
    { bot := ‚ü® Œª U, {id_sieve U}, 
        by {
            tidy,
            rw a,
            rw pullback_id_sieve,
        }, by {
            tidy,
            have H1 : (ùüô X) ‚àà S.map X,
                rw h,
                tidy,
            have H := a X (ùüô X) H1,
            rw <- H,
            apply sieve_ext, ext,
            have H : x_1 = x_1 ‚â´ ùüô X := by tidy,
            split, {
                intro hx,
                rw H at hx,
                exact hx,
            }, {
                intro hx,
                have : (x_1 ‚â´ ùüô X) ‚àà T.map x := hx,
                rw <- H at this,
                exact this,
            },
        }, by tidy‚ü©,
    bot_le := by {
        intros J U S hS,
        have H : S = id_sieve U := by tidy,
        rw H,
        exact J.id U,
      },
      ..grothendieck_topology_partial_order C}
end topologies

section topologies
universes v u

--SGA 4 II 1.1.6. topology generated by family of morphisms 
def topology_gen_by {C : Type u} [iC : category.{v} C] (fa : Œ† X Y : C, set (Y ‚ü∂ X)):
    @grothendieck_topology C iC := lattice.Inf {J | ‚àÄ X Y : C, sieve_gen_by (fa X) ‚àà J.coverings X}

--SGA 4 II def 1.3. pretopology
structure pretopology (C : Type u) [iC : category.{v} C] :=
(coverings : Œ† X Y : C, set (Y ‚ü∂ X))
--TODO define this and prove Prop 1.4

end topologies

section sites
universes v u

variables (cat : Type u) [icat : category.{v} cat]
include icat

-- SGA 4 II 1.1.5
structure site := 
(top : @grothendieck_topology cat icat)

variable C : site cat

def covering_morphisms (X : cat) (fa : Œ† Y : cat, set (Y ‚ü∂ X)) :=
    sieve_gen_by fa ‚àà C.top.coverings X
end sites

section sites
universe v
open topological_space

-- this is quite bad, especially base_change 
-- I find it annoying to switch between set theory 
-- and the category of open sets... there's some of ulift, plift magic
-- there should definitely be an easy way of doing this 
-- (tidy doesn't work / produces something with I don't understand)

-- maybe it can be simplified by defining it as the topology generated by open covers.
def grothendieck_topology_of_topology (M : Top.{v}): 
    @grothendieck_topology (opens M) opens.opens_category := 
    ‚ü®Œª X : opens M, {s | ‚àÄ x : M, x ‚àà X ‚Üí ‚àÉ Y : opens M, s.map Y ‚â† ‚àÖ ‚àß x ‚àà Y }, 
    by { 
        intros X Y s f hs,
        intros x hx,
        have hx' : x ‚àà X,
            have H : Y ‚äÜ X := f.down.down,
            exact H hx,
        have h := hs x hx',
        cases h with Z hZ,
        refine ‚ü®Z ‚à© Y, _, _‚ü©,
        {   rw set.ne_empty_iff_nonempty,
            rw set.ne_empty_iff_nonempty at hZ,
            cases hZ.1 with i hi,
            have h1 : Z ‚à© Y ‚â§ Y,
            {   intros w hw,
                have h3 : (Z ‚à© Y).val = Z.val ‚à© Y.val := by tidy,
                rw h3 at hw,
                rw set.mem_inter_iff at hw,
                exact hw.2, },
            let g : Z ‚à© Y ‚ü∂ Y := ulift.up (plift.up h1),
            have h2 : Z ‚à© Y ‚â§ Z,
            {   intros w hw,
                have h3 : (Z ‚à© Y).val = Z.val ‚à© Y.val := by tidy,
                rw h3 at hw,
                rw set.mem_inter_iff at hw,
                exact hw.1, },
            let t : Z ‚à© Y ‚ü∂ Z := ulift.up (plift.up h2),
            have H : t ‚â´ i ‚àà s.map (Z ‚à© Y), 
                apply s.comp, exact hi,
            have H1 : t ‚â´ i = g ‚â´ f := by tidy,
            rw H1 at H,
            have H2 : g ‚àà (pullback_sieve f s).map (Z ‚à© Y) := H,
            existsi g, exact H,
        }, {
            split,
            exact hZ.2,
            exact hx,
        },
    }, by {
        intros X S T hS H x hx,
        cases hS x hx with Y hY,
        rw set.ne_empty_iff_nonempty at hY,
        cases hY.1 with i hi,
        cases H Y i hi x hY.2 with Z hZ,
        rw set.ne_empty_iff_nonempty at hZ,
        cases hZ.1 with j hj,

        refine ‚ü®Z, _, hZ.2‚ü©,
        rw set.ne_empty_iff_nonempty,
        existsi j ‚â´ i,
        exact hj,
    },
    by { 
        intros X x hx,
        refine ‚ü®X, _, hx‚ü©,
        intro h,
        set s : sieve.{v} X := id_sieve X with sdef,
        have h1 : ùüô X ‚àà s.map X := by tidy,
        rw h at h1,
        rw set.mem_empty_eq at h1,
        exact h1,
    }‚ü©

end sites

open opposite

universes v u

variables {C : Type u} [ùíû : category.{v} C]
include ùíû

structure covering (U : C) :=
(Œπ : Type v)
(obj : Œπ ‚Üí C)
(hom : Œ† i, obj i ‚ü∂ U)

set_option pp.universes true

/- redefined this as category + grothendieck topology
structure site :=
(index : C ‚Üí Type v)
(coverings : Œ† (U : C), index U ‚Üí covering.{v} U)
(pullback : ‚àÄ {U V: C} (k : index U) (g : V ‚ü∂ U), ‚àÉ (l : index V), ‚àÄ (j : (coverings V l).Œπ), 
‚àÉ (i : (coverings U k).Œπ) (h : ((coverings V l).obj j) ‚ü∂ ((coverings U k).obj i)), 
(coverings V l).hom j ‚â´ g = h ‚â´ ((coverings U k).hom i))
-/

variables {D : Type u} [Dc : category.{v} D]
variables [products : limits.has_products.{v} D] [pullbacks : limits.has_pullbacks.{v} C]
variables {F : C·µí·µñ ‚•§ D}
include Dc products pullbacks

def asdf (U : C) (CU : covering.{v} U) (i j : CU.Œπ) := limits.pullback (CU.hom i) (CU.hom j)

/-def obj1 (U : C) (CU : covering U) := (limits.pullback (CU.hom i) (CU.hom j)) -/

def fan1 (U : C) (CU : covering.{v} U) := Œª (k : CU.Œπ √ó CU.Œπ), F.obj (op ( limits.pullback (CU.hom k.1) (CU.hom k.2)))

def intersection_prod (U : C) (CU : covering.{v u} U) := limits.pi_obj.{v u} (@fan1 _ _ _ _ _ _ F U CU)

/- TODO: 
Get maps from product of pullbacks to product of U_i
-/

end category_theory.limits
end category_theory