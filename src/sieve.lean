import category_theory.opposites
import category_theory.hom_functor
import category_theory.limits.shapes.products
import category_theory.limits.shapes.pullbacks
import topology.opens
import topology.category.Top.opens

open opposite
open category_theory


set_option pp.universes true

section sieves

universes v u
variables {C : Type u} [ùíû : category.{v} C]
include ùíû

 /- Maybe define sieve as a subfunctor? (but then I have to define subfunctor...)
 
 structure subfunctor (F : C ‚•§ D) :=
(G : C ‚•§ D)
(obj : ‚àÄ (c : C), ) -/

/- Could potentially simplify hom definition by using hom_obj in hom_functor.lean somehow...-/
structure sieve (X : C) := 
(map : Œ† (Y : C), set (Y ‚ü∂ X))
(comp : ‚àÄ (Y Z: C) (g : Y ‚ü∂ Z) (f ‚àà map Z), g ‚â´ f ‚àà map Y)

instance sieve_partial_order {U : C} : partial_order (sieve U) :=
    {   le := (Œª S, Œª T, S.map ‚â§ T.map),
        le_refl := by tidy,
        le_trans := by tidy,
        le_antisymm := by {intros a b hab hba, cases a, cases b, tidy, }
    }

instance sieve_has_inf {U : C} : lattice.semilattice_inf (sieve U) :=
    { inf := Œª S, Œª T, ‚ü®S.map ‚äì T.map, by {
        intros Y Z g f hf,
        have h1 : (S.map ‚äì T.map) ‚â§ S.map := lattice.inf_le_left,
        have hS := S.comp Y Z g f (h1 Z hf),
        have h2 : (S.map ‚äì T.map) ‚â§ T.map := lattice.inf_le_right,
        have hT := T.comp Y Z g f (h2 Z hf),
        exact ‚ü®hS, hT‚ü©, }‚ü©,
      inf_le_left := by tidy,
      inf_le_right := by tidy,
      le_inf := by tidy,
      ..sieve_partial_order
    }

--TODO inf and sup of sets of sieves SGA 4 I 4.3.2.
--TODO sieve generated by family of morphisms SGA 4 I 4.3.3.

structure sieve_domain {X : C} (S : sieve X) :=
(Y : C)
(f : Y ‚ü∂ X)
(in_cover : f ‚àà S.map Y)

def id_sieve (X : C) : sieve X := ‚ü®Œª (Y : C), {f | true}, by tidy‚ü©

def pullback_sieve {X Y : C} (f : Y ‚ü∂ X) (S : sieve X) : sieve Y 
    := ‚ü®Œª Z, {g | g ‚â´ f ‚àà S.map Z}, by {tidy, apply S.comp, exact H}‚ü©

lemma pullback_id_sieve {X Y : C} (f : Y ‚ü∂ X) 
    : pullback_sieve f (id_sieve X) = id_sieve Y := by tidy

omit ùíû
end sieves

section topologies
universes v u

variables (C : Type u) [category.{v} C]

-- SGA 4 II Def 1.1.
structure grothendieck_topology :=
(coverings : Œ† (X : C), set (sieve.{v} X))
(base_change : ‚àÄ (X Y : C) (S : sieve.{v} X) (f : Y ‚ü∂ X), 
    S ‚àà coverings X ‚Üí (pullback_sieve f S) ‚àà coverings Y)
(local_character : ‚àÄ (X : C) (S T : sieve.{v} X) (_ : S ‚àà coverings X), 
    (‚àÄ (Y : C) (f : Y ‚ü∂ X) (_ : f ‚àà S.map Y), 
         (pullback_sieve f T) ‚àà coverings Y) ‚Üí T ‚àà coverings X)
(id : ‚àÄ (X : C), id_sieve X ‚àà coverings X)

--TODO coverings is 'cofiltrant' [SGA 4 II 1.1.1.]

-- how to generate this? @[ext] didn't work for because of the explicit universe parameters
lemma grothendieck_topology_ext {J K : grothendieck_topology C}:
    J.coverings = K.coverings ‚Üí J = K := by {cases K, intro H, cases J, tidy}

-- SGA 4 II 1.1.2. topologies plus ou moins fine
instance grothendieck_topology_partial_order:
    partial_order (grothendieck_topology C) :=
    {   le := (Œª J, Œª K, J.coverings ‚â§ K.coverings),
        le_refl := by {intros J X, exact le_refl (J.coverings X), },
        le_trans := by {intros J K L hJK hKL X, exact le_trans (hJK X) (hKL X),},
        le_antisymm := by {
            intros J K hJK hKJ, 
            apply grothendieck_topology_ext, ext X S,
            split,
            intro hS,
            exact hJK X hS,
            intro hS,
            exact hKJ X hS, }
    }

-- SGA 4 II 1.1.3. intersection topology
instance grothendieck_topology_has_Inf:
    lattice.has_Inf (grothendieck_topology C) :=
    { Inf := Œª T : set (grothendieck_topology C), ‚ü® Œª U : C, 
            ‚ãÇ (J : grothendieck_topology C) (H : J ‚àà T), J.coverings U,
        by { tidy, apply H_w.base_change, exact a H_w H_w_1, },
        by { 
            tidy, 
            apply H_w.local_character X S T_1, 
            exact _x H_w H_w_1,
            intros Y f hf,
            exact a Y f hf H_w H_w_1, },
        by {tidy, exact H_w.id X, } ‚ü© }

-- SGA 4 II 1.1.4. discrete (top) and chaotic (bot) topologies
instance grothendieck_topology_order_top:
    lattice.order_top (grothendieck_topology C) :=
    { top := sorry,
      le_top := sorry,
      ..grothendieck_topology_partial_order C}

instance grothendieck_topology_order_bot:
    lattice.order_bot (grothendieck_topology C) :=
    { bot := sorry,
      bot_le := sorry,
      ..grothendieck_topology_partial_order C}
end topologies

--TODO topology generated by family of morphisms SGA 4 II 1.1.6.

section sites
universes v u

-- SGA 4 II 1.1.5
structure site := 
(cat : Type u) 
[icat : category.{v} cat]
(top : @grothendieck_topology cat icat)

end sites

section sites
universe v
open topological_space

-- this is quite bad, especially base_change 
-- I find it annoying to switch between set theory 
-- and the category of open sets... there's some of ulift, plift magic
-- there should definitely be an easy way of doing this 
-- (tidy doesn't work / produces something with I don't understand)

-- maybe it can be simplified by defining it as the topology generated by open covers.
def grothendieck_topology_of_topology (M : Top.{v}): 
    @grothendieck_topology (opens M) opens.opens_category := 
    ‚ü®Œª X : opens M, {s | ‚àÄ x : M, x ‚àà X ‚Üí ‚àÉ Y : opens M, s.map Y ‚â† ‚àÖ ‚àß x ‚àà Y }, 
    by { 
        intros X Y s f hs,
        intros x hx,
        have hx' : x ‚àà X,
            have H : Y ‚äÜ X := f.down.down,
            exact H hx,
        have h := hs x hx',
        cases h with Z hZ,
        refine ‚ü®Z ‚à© Y, _, _‚ü©,
        {   rw set.ne_empty_iff_nonempty,
            rw set.ne_empty_iff_nonempty at hZ,
            cases hZ.1 with i hi,
            have h1 : Z ‚à© Y ‚â§ Y,
            {   intros w hw,
                have h3 : (Z ‚à© Y).val = Z.val ‚à© Y.val := by tidy,
                rw h3 at hw,
                rw set.mem_inter_iff at hw,
                exact hw.2, },
            let g : Z ‚à© Y ‚ü∂ Y := ulift.up (plift.up h1),
            have h2 : Z ‚à© Y ‚â§ Z,
            {   intros w hw,
                have h3 : (Z ‚à© Y).val = Z.val ‚à© Y.val := by tidy,
                rw h3 at hw,
                rw set.mem_inter_iff at hw,
                exact hw.1, },
            let t : Z ‚à© Y ‚ü∂ Z := ulift.up (plift.up h2),
            have H : t ‚â´ i ‚àà s.map (Z ‚à© Y), 
                apply s.comp, exact hi,
            have H1 : t ‚â´ i = g ‚â´ f := by tidy,
            rw H1 at H,
            have H2 : g ‚àà (pullback_sieve f s).map (Z ‚à© Y) := H,
            existsi g, exact H,
        }, {
            split,
            exact hZ.2,
            exact hx,
        },
    }, by {
        intros X S T hS H x hx,
        cases hS x hx with Y hY,
        rw set.ne_empty_iff_nonempty at hY,
        cases hY.1 with i hi,
        cases H Y i hi x hY.2 with Z hZ,
        rw set.ne_empty_iff_nonempty at hZ,
        cases hZ.1 with j hj,

        refine ‚ü®Z, _, hZ.2‚ü©,
        rw set.ne_empty_iff_nonempty,
        existsi j ‚â´ i,
        exact hj,
    },
    by { 
        intros X x hx,
        refine ‚ü®X, _, hx‚ü©,
        intro h,
        set s : sieve.{v} X := id_sieve X with sdef,
        have h1 : ùüô X ‚àà s.map X := by tidy,
        rw h at h1,
        rw set.mem_empty_eq at h1,
        exact h1,
    }‚ü©

end sites

section sheaves
universes w v u

variables {C : Type u} [CCat : category.{v} C] 
variables {D : Type w} [DCat : category.{max u v} D]
variables [products : limits.has_products.{max u v} D]
include CCat products

def restriction_map (F : C·µí·µñ ‚•§ D) {U : C} (S : @sieve.{v} C CCat U) : 
    F.obj (op U) ‚ü∂ ‚àè (Œª k : sieve_domain S, F.obj (op k.Y)) := 
    limits.pi.lift (Œª k : sieve_domain S, F.map k.f.op) 

include DCat

structure separated_presheaf (J : @grothendieck_topology C CCat) :=
(F : C·µí·µñ ‚•§ D)
(identity : ‚àÄ {U : C} (S : sieve.{v} U) (S ‚àà J.coverings U), 
    mono (restriction_map F S))

omit CCat products
end sheaves
