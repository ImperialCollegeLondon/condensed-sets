import category_theory.opposites
import category_theory.hom_functor
import category_theory.limits.shapes.products
import category_theory.limits.shapes.pullbacks
import topology.opens
import topology.category.Top.opens

open opposite
open category_theory


set_option pp.universes true

section sieves

universes v u
variables {C : Type u} [ùíû : category.{v} C]
include ùíû

 /- Maybe define sieve as a subfunctor? (but then I have to define subfunctor...)
 
 structure subfunctor (F : C ‚•§ D) :=
(G : C ‚•§ D)
(obj : ‚àÄ (c : C), ) -/

/- Could potentially simplify hom definition by using hom_obj in hom_functor.lean somehow...-/
structure sieve (X : C) := 
(map : Œ† (Y : C), set (Y ‚ü∂ X))
(comp : ‚àÄ (Y Z: C) (g : Y ‚ü∂ Z) (f ‚àà map Z), g ‚â´ f ‚àà map Y)

instance sieve_partial_order {U : C} : partial_order (sieve U) :=
    {   le := (Œª S, Œª T, S.map ‚â§ T.map),
        le_refl := by tidy,
        le_trans := by tidy,
        le_antisymm := by {intros a b hab hba, cases a, cases b, tidy, }
    }

instance sieve_semilattice_inf {U : C} : lattice.semilattice_inf (sieve U) :=
    { inf := Œª S, Œª T, ‚ü®S.map ‚äì T.map, by {
        intros Y Z g f hf,
        have h1 : (S.map ‚äì T.map) ‚â§ S.map := lattice.inf_le_left,
        have hS := S.comp Y Z g f (h1 Z hf),
        have h2 : (S.map ‚äì T.map) ‚â§ T.map := lattice.inf_le_right,
        have hT := T.comp Y Z g f (h2 Z hf),
        exact ‚ü®hS, hT‚ü©, }‚ü©,
      inf_le_left := by tidy,
      inf_le_right := by tidy,
      le_inf := by tidy,
      ..sieve_partial_order
    }

instance sieve_semilattice_sup {U : C} : lattice.semilattice_sup (sieve U) :=
    { sup := Œª S, Œª T, ‚ü®S.map ‚äî T.map, by {
        intros Y Z g f hf,
        cases hf with hS hT, {
        have h := S.comp Y Z g f hS,
        have h1 : S.map ‚â§ (S.map ‚äî T.map) := lattice.le_sup_left,
        exact (h1 Y) h, }, {
        have h := T.comp Y Z g f hT,
        have h1 : T.map ‚â§ (S.map ‚äî T.map) := lattice.le_sup_right,
        exact (h1 Y) h, } }‚ü©,
      le_sup_left := by {tidy, left, exact a_2,},
      le_sup_right := by {tidy, right, exact a_2,},
      sup_le := by tidy,
      ..sieve_partial_order
    }

--inf and sup of sets of sieves SGA 4 I 4.3.2.
instance sieve_complete_lattice {U : C} : lattice.complete_lattice (sieve U) :=
{
    top := ‚ü® Œª Y, {a | true }, by tidy ‚ü©,
    le_top := by tidy,
    bot := ‚ü® Œª Y, ‚àÖ, by tidy ‚ü©,
    bot_le := by tidy,
    Inf := Œª A, ‚ü® Œª V, {f : V ‚ü∂ U | ‚àÄ S : sieve U, S ‚àà A ‚Üí f ‚àà S.map V}, by {
        intros Y Z g f hf S hS,
        apply S.comp,
        exact hf S hS,
    }‚ü©, 
    Inf_le := by {
        intros A S hS V f hf,
        exact hf S hS,
    },
    le_Inf := by {
        intros A S hS V f hf,
        intros T hT,
        exact (hS T hT) V hf,
    },
    Sup := sorry,
    Sup_le := sorry,
    le_Sup := sorry,
    ..sieve_semilattice_inf,
    ..sieve_semilattice_sup,
}

--SGA 4 I 4.3.3. sieve generated by family of morphisms 
def sieve_gen_by {X : C} (fa : Œ† Y : C, set (Y ‚ü∂ X)) : sieve X := 
    lattice.Inf {S : sieve X | fa ‚â§ S.map }

def id_sieve (X : C) : sieve X := ‚ü®Œª (Y : C), {f | true}, by tidy‚ü©

def pullback_sieve {X Y : C} (f : Y ‚ü∂ X) (S : sieve X) : sieve Y 
    := ‚ü®Œª Z, {g | g ‚â´ f ‚àà S.map Z}, by {tidy, apply S.comp, exact H}‚ü©

lemma pullback_id_sieve {X Y : C} (f : Y ‚ü∂ X) 
    : pullback_sieve f (id_sieve X) = id_sieve Y := by tidy

lemma sieve_ext {X : C} {S T : sieve X} : S.map = T.map ‚Üí S = T
    := by {cases S, intro H, cases T, tidy, }

structure sieve_domain {X : C} (S : sieve X) :=
(Y : C)
(f : Y ‚ü∂ X)
(in_cover : f ‚àà S.map Y)

omit ùíû
end sieves
